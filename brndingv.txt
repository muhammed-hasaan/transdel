"use client"
import "./Step1.css"

const Step1 = (props) => {
  const handleThinkingTimeChange = (e) => {
    props.candidateThinkingTime(e.target.value)
  }

  const handleMaxAnswerLengthChange = (e) => {
    props.candidateMaxAnswerLength(e.target.value)
  }

  const handleBrandingChange = (e) => {
    props.brandingColorOrLogo(e.target.value)
  }

  const handleRetakesChange = (e) => {
    props.answerRetakesAllowed(e.target.value)
  }

  // Dynamic notification handlers
  const handleAddNotification = () => {
    if (props.candidateNotifications.length < 3) {
      const newNotification = {
        id: Date.now(), // Unique ID for each notification
        method: "Email",
        to: "",
        trigger: "",
      }
      props.setCandidateNotifications([...props.candidateNotifications, newNotification])
    }
  }

  const handleDeleteNotification = (id) => {
    const updatedNotifications = props.candidateNotifications.filter((notification) => notification.id !== id)
    props.setCandidateNotifications(updatedNotifications)
  }

  const handleNotificationChange = (id, field, value) => {
    const updatedNotifications = props.candidateNotifications.map((notification) => {
      if (notification.id === id) {
        const updatedNotification = { ...notification, [field]: value }

        // Reset trigger when "to" changes
        if (field === "to") {
          updatedNotification.trigger = ""
        }

        return updatedNotification
      }
      return notification
    })
    props.setCandidateNotifications(updatedNotifications)
  }

  // Get trigger options based on "to" value
  const getTriggerOptions = (toValue) => {
    switch (toValue) {
      case "Invitation":
        return ["On Invitation", "If no response in 24 hours"]
      case "Reminder":
        return ["If no response in 24 hours", "If no response in 48 hours", "If no response in 72 hours"]
      case "Interview Completion":
        return ["On Interview Completion"]
      default:
        return []
    }
  }

  return (
    <div className="listandcreateinterviewsstep1-flex">
      <div style={{ paddingLeft: "25px" }}>
        <button
          onClick={props.prevStep}
          className="listandcreateinterviewsstep1-video-interview-create-button"
          style={{ marginBottom: "20px" }}
        >
          Back
        </button>
      </div>
      <div
        style={{
          width: "100%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
        }}
      >
        <div className="listandcreateinterviewsstep1-video-interview-container" style={{ maxWidth: "96.3%" }}>
          <div className="listandcreateinterviewsstep1-video-interview-section">
            <div className="listandcreateinterviewsstep1-video-interview-left">
              <div className="listandcreateinterviewsstep1-video-interview-placeholder-image">
                <div className="listandcreateinterviewsstep1-video-icon">
                  <svg width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M14.7295 2H9.26953V6H14.7295V2Z" fill="currentColor" />
                    <path d="M16.7295 8V6H14.7295V8H16.7295Z" fill="currentColor" />
                    <path d="M16.7295 8H18.7295V16H16.7295V8Z" fill="currentColor" />
                    <path d="M14.7295 18V16H9.26953V18H14.7295Z" fill="currentColor" />
                    <path d="M7.26953 16V8H9.26953V6H7.26953V8H5.26953V16H7.26953Z" fill="currentColor" />
                    <path d="M12 10L15 12.5L12 15V10Z" fill="white" />
                  </svg>
                </div>
              </div>
              <div className="listandcreateinterviewsstep1-content-wrapper">
                <h2 className="listandcreateinterviewsstep1-main-title">Video Interview Setup</h2>
                <p className="listandcreateinterviewsstep1-main-description">
                  Set up your interview and create a great candidate experience.
                </p>
                <button className="listandcreateinterviewsstep1-video-interview-create-button" onClick={props.nextStep}>
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path
                      d="M12 5V19M5 12H19"
                      stroke="currentColor"
                      strokeWidth="2"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                    />
                  </svg>
                  Create Interview
                </button>
              </div>
            </div>

            <div className="listandcreateinterviewsstep1-video-interview-right">
              <div className="listandcreateinterviewsstep1-settings-header">
                <h3>Interview Settings</h3>
              </div>

              <div className="listandcreateinterviewsstep1-video-interview-setting-item">
                <div className="listandcreateinterviewsstep1-setting-info">
                  <span>Thinking Time</span>
                  <small>Time to prepare answer</small>
                </div>
                <select
                  className="listandcreateinterviewsstep1-setting-select"
                  onChange={handleThinkingTimeChange}
                  value={props.candidateThinkingTimeValue}
                >
                  <option value="" disabled>
                    Thinking Time
                  </option>
                  <option value="30 seconds">30 seconds</option>
                  <option value="1 minute">1 minute</option>
                  <option value="2 minutes">2 minutes</option>
                  <option value="3 minutes">3 minutes</option>
                  <option value="4 minutes">4 minutes</option>
                  <option value="5 minutes">5 minutes</option>
                </select>
              </div>

              <div className="listandcreateinterviewsstep1-video-interview-setting-item">
                <div className="listandcreateinterviewsstep1-setting-info">
                  <span>Answer Length</span>
                  <small>Max recording time</small>
                </div>
                <select
                  className="listandcreateinterviewsstep1-setting-select"
                  onChange={handleMaxAnswerLengthChange}
                  value={props.candidateMaxAnswerLengthValue}
                >
                  <option value="" disabled>
                    Answer Length
                  </option>
                  <option value="1 minute">1 minute</option>
                  <option value="2 minutes">2 minutes</option>
                  <option value="3 minutes">3 minutes</option>
                  <option value="4 minutes">4 minutes</option>
                  <option value="5 minutes">5 minutes</option>
                </select>
              </div>

              <div className="listandcreateinterviewsstep1-video-interview-setting-item">
                <div className="listandcreateinterviewsstep1-setting-info">
                  <span>Branding</span>
                  <small>Custom appearance</small>
                </div>
                <select
                  className="listandcreateinterviewsstep1-setting-select"
                  onChange={handleBrandingChange}
                  value={props.brandingColorOrLogoValue}
                >
                  <option value="" disabled>
                    Branding
                  </option>
                  <option value="No">No</option>
                  <option value="Logo">Logo</option>
                  <option value="Color">Color</option>
                </select>
              </div>

              <div className="listandcreateinterviewsstep1-video-interview-setting-item">
                <div className="listandcreateinterviewsstep1-setting-info">
                  <span>Retakes</span>
                  <small>Allow re-recording</small>
                </div>
                <select
                  className="listandcreateinterviewsstep1-setting-select"
                  onChange={handleRetakesChange}
                  value={props.answerRetakesAllowedValue}
                >
                  <option value="" disabled>
                    Retakes
                  </option>
                  <option value="None">None</option>
                  <option value="Allowed">Allowed</option>
                  <option value="Not Allowed">Not Allowed</option>
                </select>
              </div>

              {/* Dynamic Candidate Notifications Section */}
              <div
                style={{
                  marginTop: "30px",
                  padding: "20px",
                  backgroundColor: "#f8f9fa",
                  borderRadius: "8px",
                  border: "1px solid #e9ecef",
                }}
              >
                <div
                  style={{
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    marginBottom: "15px",
                  }}
                >
                  <h3
                    style={{
                      fontSize: "16px",
                      fontWeight: "600",
                      color: "#333",
                      margin: 0,
                    }}
                  >
                    Candidate Notifications
                  </h3>
                  <button
                    style={{
                      fontSize: "12px",
                      color: "#007bff",
                      background: "none",
                      border: "none",
                      cursor: "pointer",
                      textDecoration: "underline",
                    }}
                  >
                    Edit templates
                  </button>
                </div>

                <p
                  style={{
                    fontSize: "13px",
                    color: "#666",
                    marginBottom: "20px",
                    margin: "0 0 20px 0",
                  }}
                >
                  Automatically notify candidates by email when inviting them to the position
                </p>

                {/* Dynamic Notification Entries */}
                {props.candidateNotifications.map((notification, index) => (
                  <div
                    key={notification.id}
                    style={{
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "space-between",
                      marginBottom: "15px",
                      padding: "15px",
                      backgroundColor: "#ffffff",
                      borderRadius: "6px",
                      border: "1px solid #e0e0e0",
                    }}
                  >
                    <div style={{ display: "flex", alignItems: "center", gap: "10px", flex: 1 }}>
                      <span style={{ fontSize: "14px", fontWeight: "500", minWidth: "60px" }}>Send</span>

                      {/* Method Dropdown - Only Email */}
                      <select
                        style={{
                          padding: "5px 10px",
                          border: "1px solid #ddd",
                          borderRadius: "4px",
                          fontSize: "13px",
                          minWidth: "80px",
                        }}
                        value={notification.method}
                        onChange={(e) => handleNotificationChange(notification.id, "method", e.target.value)}
                      >
                        <option value="Email">Email</option>
                      </select>

                      <span style={{ fontSize: "14px", minWidth: "20px" }}>to</span>

                      {/* To Dropdown */}
                      <select
                        style={{
                          padding: "5px 10px",
                          border: "1px solid #ddd",
                          borderRadius: "4px",
                          fontSize: "13px",
                          minWidth: "140px",
                        }}
                        value={notification.to}
                        onChange={(e) => handleNotificationChange(notification.id, "to", e.target.value)}
                      >
                        <option value="" disabled>
                          Select Type
                        </option>
                        <option value="Invitation">Invitation</option>
                        <option value="Reminder">Reminder</option>
                        <option value="Interview Completion">Interview Completion</option>
                      </select>

                      {/* Trigger Dropdown - Conditional based on "to" value */}
                      {notification.to && (
                        <select
                          style={{
                            padding: "5px 10px",
                            border: "1px solid #ddd",
                            borderRadius: "4px",
                            fontSize: "13px",
                            minWidth: "160px",
                          }}
                          value={notification.trigger}
                          onChange={(e) => handleNotificationChange(notification.id, "trigger", e.target.value)}
                        >
                          <option value="" disabled>
                            Select Trigger
                          </option>
                          {getTriggerOptions(notification.to).map((option) => (
                            <option key={option} value={option}>
                              {option}
                            </option>
                          ))}
                        </select>
                      )}
                    </div>

                    {/* Delete Button */}
                    <div style={{ display: "flex", gap: "10px", marginLeft: "10px" }}>
                      <button
                        onClick={() => handleDeleteNotification(notification.id)}
                        style={{
                          width: "24px",
                          height: "24px",
                          border: "none",
                          background: "#ff4757",
                          color: "white",
                          borderRadius: "4px",
                          cursor: "pointer",
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          fontSize: "12px",
                        }}
                        title="Delete Notification"
                      >
                        üóëÔ∏è
                      </button>
                    </div>
                  </div>
                ))}

                {/* Add Notification Button */}
                {props.candidateNotifications.length < 3 && (
                  <div
                    onClick={handleAddNotification}
                    style={{
                      display: "flex",
                      alignItems: "center",
                      gap: "8px",
                      marginTop: "15px",
                      cursor: "pointer",
                      padding: "10px",
                      backgroundColor: "#ffffff",
                      borderRadius: "6px",
                      border: "2px dashed #007bff",
                      transition: "all 0.2s ease",
                    }}
                    onMouseEnter={(e) => {
                      e.target.style.backgroundColor = "#f8f9ff"
                    }}
                    onMouseLeave={(e) => {
                      e.target.style.backgroundColor = "#ffffff"
                    }}
                  >
                    <div
                      style={{
                        width: "20px",
                        height: "20px",
                        borderRadius: "50%",
                        backgroundColor: "#007bff",
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center",
                        color: "white",
                        fontSize: "12px",
                        fontWeight: "bold",
                      }}
                    >
                      +
                    </div>
                    <span
                      style={{
                        fontSize: "14px",
                        fontWeight: "500",
                        color: "#007bff",
                      }}
                    >
                      Add Notification ({props.candidateNotifications.length}/3)
                    </span>
                  </div>
                )}

                {/* Max limit message */}
                {props.candidateNotifications.length >= 3 && (
                  <div
                    style={{
                      marginTop: "15px",
                      padding: "10px",
                      backgroundColor: "#fff3cd",
                      border: "1px solid #ffeaa7",
                      borderRadius: "4px",
                      fontSize: "13px",
                      color: "#856404",
                      textAlign: "center",
                    }}
                  >
                    Maximum of 3 notifications allowed
                  </div>
                )}

                {/* No notifications message */}
                {props.candidateNotifications.length === 0 && (
                  <div
                    style={{
                      marginTop: "15px",
                      padding: "20px",
                      backgroundColor: "#f8f9fa",
                      border: "1px solid #dee2e6",
                      borderRadius: "4px",
                      fontSize: "13px",
                      color: "#6c757d",
                      textAlign: "center",
                    }}
                  >
                    No notifications configured. Click "Add Notification" to set up candidate notifications.
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}

export default Step1












const mongoose = require("mongoose")

// Define the Interview Schema
const InterviewSchema = new mongoose.Schema(
  {
    interviewTitle: {
      type: String,
    },
    candidateThinkingTime: {
      type: String,
    },
    candidateMaxAnswerLength: {
      type: String, // Length in seconds
    },
    brandingColorOrLogo: {
      type: String,
    },
    answerRetakesAllowed: {
      type: String, // Number of retakes allowed
    },
    // Updated field for dynamic candidate notifications
    candidateNotifications: [
      {
        id: { type: Number, required: true }, // Unique identifier for each notification
        method: { type: String, required: true, default: "Email" }, // Only Email for now
        to: {
          type: String,
          required: true,
          enum: ["Invitation", "Reminder", "Interview Completion"],
        }, // Type of notification
        trigger: { type: String, required: true }, // When to trigger the notification
        createdAt: { type: Date, default: Date.now },
      },
    ],
    interviewStart: {
      video: { type: String }, // URL or path for the video
      title: { type: String },
      tag: { type: String },
    },
    questions: [
      {
        id: { type: Number, required: true },
        video: { type: String }, // URL or path for the question video
        title: { type: String },
        description: { type: String },
        Timetothink: { type: String }, // Time to think for this specific question
        Timetoanswer: { type: String }, // Time to answer for this specific question
        Retakes: { type: String }, // Number of retakes for this specific question
      },
    ],
    farewell: {
      id: { type: String },
      video: { type: String }, // URL or path for the video
      title: { type: String },
      description: { type: String },
    },
    email: {
      type: String,
      required: true,
    },
    Status: {
      type: String,
    },
  },
  {
    timestamps: true, // Automatically add createdAt and updatedAt timestamps
  },
)

module.exports = mongoose.model("Interview", InterviewSchema)


schema









"use client"
import { useState, useEffect } from "react"
import "./CreateInterview.css"
import { Link } from "react-router-dom"
import Step1 from "./InterviewCreating-steps/Step1/Step1"
import Step2 from "./InterviewCreating-steps/Step2/Step2"
import { useNavigate } from "react-router-dom"
import Swal from "sweetalert2"
import { postReq, putReq } from "../../../../api/request"

const CreateInterview = () => {
  const navigate = useNavigate()
  const [users, setUsers] = useState([])
  const [limit, setLimit] = useState(3)
  const [allInterviewsData, setAllInterviewsData] = useState([])

  const loginedEmail = JSON.parse(localStorage.getItem("LoginedEmail"))

  // Step 1 Settings
  const [candidateThinkingTime, setCandidateThinkingTime] = useState("1 minute")
  const [candidateMaxAnswerLength, setCandidateMaxAnswerLength] = useState("2 minutes")
  const [brandingColorOrLogo, setBrandingColorOrLogo] = useState("No")
  const [answerRetakesAllowed, setAnswerRetakesAllowed] = useState("Allowed")

  // Updated state for dynamic candidate notifications - starts as empty array
  const [candidateNotifications, setCandidateNotifications] = useState([])

  // Step 2 Data
  const [interviewStartVideo, setInterviewStartVideo] = useState(null)
  const [interviewStartTitle, setInterviewStartTitle] = useState("")
  const [interviewStartTag, setInterviewStartTag] = useState("")
  const [questions, setQuestions] = useState([])
  const [farewell, setFarewell] = useState([])

  const [step, setStep] = useState(1)
  const [isUploading, setIsUploading] = useState(false)

  useEffect(() => {
    let userIntervalId

    const fetchUsers = async () => {
      try {
        const data = await postReq("/users/GetUserByEmail", { companyEmail: loginedEmail })
        if (data && data.User) {
          setUsers(data.User)
        } else {
          console.error("No data returned from the server.")
        }
      } catch (error) {
        console.error("Error fetching users:", error)
      }
    }

    fetchUsers()
    userIntervalId = setInterval(fetchUsers, 5000)

    return () => clearInterval(userIntervalId)
  }, [loginedEmail])

  useEffect(() => {
    let interviewIntervalId

    const fetchInterviews = async () => {
      try {
        const result = await postReq("/interview/GetInterviewsbyEmail", { email: loginedEmail })
        if (result) {
          console.log("interviews", result)
          setAllInterviewsData(result.interviews)
        } else {
          console.error(result?.message || "Error fetching interviews.")
        }
      } catch (error) {
        console.error("Error fetching interviews:", error)
      }
    }

    fetchInterviews()
    interviewIntervalId = setInterval(fetchInterviews, 5000)

    return () => clearInterval(interviewIntervalId)
  }, [loginedEmail])

  useEffect(() => {
    let interviewCount = 0

    allInterviewsData.forEach((data) => {
      if (loginedEmail === data.email) {
        interviewCount += 1
      }
    })

    if (loginedEmail === users.companyEmail) {
      if (users.Limit) {
        setLimit(users.Limit)
      } else {
        setLimit(3)
      }
    }

    if (interviewCount >= limit) {
      navigate("/All-Interviews")
    }
  }, [allInterviewsData, users, loginedEmail, limit, navigate])

  const moveToStepForward = () => {
    if (candidateThinkingTime && candidateMaxAnswerLength && brandingColorOrLogo && answerRetakesAllowed) {
      // Validate notifications if any are added
      if (candidateNotifications.length > 0) {
        const incompleteNotifications = candidateNotifications.filter(
          (notification) => !notification.to || !notification.trigger,
        )

        if (incompleteNotifications.length > 0) {
          Swal.fire({
            icon: "warning",
            title: "Incomplete Notifications",
            text: "Please complete all notification settings or remove incomplete ones.",
            toast: true,
            position: "top-end",
            showConfirmButton: false,
            timer: 3000,
            timerProgressBar: true,
          })
          return
        }
      }

      setStep(step + 1)
    } else {
      Swal.fire({
        icon: "warning",
        title: "Please fill all the required fields",
        toast: true,
        position: "top-end",
        showConfirmButton: false,
        timer: 3000,
        timerProgressBar: true,
      })
    }
  }

  const moveToStepPrevious = () => {
    if (step === 1) {
      navigate("/All-Interviews")
    } else {
      setStep(step - 1)
    }
  }

  const uploadToCloudinary = async (file) => {
    const formData = new FormData()
    formData.append("file", file)
    formData.append("upload_preset", "InterviewVideo")

    try {
      const response = await fetch(`https://api.cloudinary.com/v1_1/dxl1ejhcc/video/upload`, {
        method: "POST",
        body: formData,
      })

      const responseData = await response.json()

      if (!response.ok) {
        console.error("Cloudinary Upload Failed:", responseData)
        throw new Error(responseData.error?.message || "Unknown error occurred")
      }

      return responseData.secure_url
    } catch (error) {
      console.error("Upload error:", error)
      throw error
    }
  }

  const saveInterview = async () => {
    // Validation
    if (
      !candidateThinkingTime ||
      !candidateMaxAnswerLength ||
      !brandingColorOrLogo ||
      !answerRetakesAllowed ||
      !interviewStartVideo ||
      !interviewStartTitle ||
      questions.length === 0 ||
      farewell.length === 0
    ) {
      let errorMessage = "Please fill all required fields: "
      const missingFields = []

      if (!candidateThinkingTime) missingFields.push("Thinking Time")
      if (!candidateMaxAnswerLength) missingFields.push("Answer Length")
      if (!brandingColorOrLogo) missingFields.push("Branding")
      if (!answerRetakesAllowed) missingFields.push("Retakes")
      if (!interviewStartVideo) missingFields.push("Interview Start Video")
      if (!interviewStartTitle) missingFields.push("Interview Start Title")
      if (questions.length === 0) missingFields.push("Questions")
      if (farewell.length === 0) missingFields.push("Farewell")

      errorMessage += missingFields.join(", ")

      Swal.fire({
        icon: "error",
        title: "Missing Required Fields",
        text: errorMessage,
      })
      return
    }

    // Validate notifications if any are added
    if (candidateNotifications.length > 0) {
      const incompleteNotifications = candidateNotifications.filter(
        (notification) => !notification.to || !notification.trigger,
      )

      if (incompleteNotifications.length > 0) {
        Swal.fire({
          icon: "error",
          title: "Incomplete Notifications",
          text: "Please complete all notification settings or remove incomplete ones.",
        })
        return
      }
    }

    // Check if all questions have required fields
    const incompleteQuestions = questions.filter((q) => !q.title || !q.description || !q.video)
    if (incompleteQuestions.length > 0) {
      Swal.fire({
        icon: "error",
        title: "Incomplete Questions",
        text: "Please ensure all questions have a title, description, and video.",
      })
      return
    }

    // Check farewell completion
    if (!farewell[0]?.title || !farewell[0]?.description || !farewell[0]?.video) {
      Swal.fire({
        icon: "error",
        title: "Incomplete Farewell",
        text: "Please ensure the farewell has a title, description, and video.",
      })
      return
    }

    setIsUploading(true)

    try {
      // Upload intro video to Cloudinary
      let introVideoUrl = interviewStartVideo
      if (interviewStartVideo && typeof interviewStartVideo === "object") {
        introVideoUrl = await uploadToCloudinary(interviewStartVideo)
      }

      // Upload question videos to Cloudinary
      const updatedQuestions = await Promise.all(
        questions.map(async (question) => {
          let videoUrl = question.video
          if (question.video && typeof question.video === "object") {
            videoUrl = await uploadToCloudinary(question.video)
          }
          return {
            ...question,
            video: videoUrl,
            Timetothink: question.Timetothink || candidateThinkingTime,
            Timetoanswer: question.Timetoanswer || candidateMaxAnswerLength,
            Retakes: question.Retakes || answerRetakesAllowed,
          }
        }),
      )

      // Upload farewell video to Cloudinary
      let farewellVideoUrl = farewell[0].video
      if (farewell[0].video && typeof farewell[0].video === "object") {
        farewellVideoUrl = await uploadToCloudinary(farewell[0].video)
      }

      const updatedFarewell = [
        {
          ...farewell[0],
          video: farewellVideoUrl,
        },
      ]

      // Prepare data for API - only include notifications if user added any
      const interviewData = {
        interviewTitle: interviewStartTitle,
        candidateThinkingTime: candidateThinkingTime,
        candidateMaxAnswerLength: candidateMaxAnswerLength,
        brandingColorOrLogo: brandingColorOrLogo,
        answerRetakesAllowed: answerRetakesAllowed,
        candidateNotifications: candidateNotifications, // This will be empty array if no notifications added
        interviewStart: {
          video: introVideoUrl,
          title: interviewStartTitle,
          tag: interviewStartTag || "interview",
        },
        questions: updatedQuestions,
        farewell: updatedFarewell[0],
        email: loginedEmail,
        Status: "Open",
      }

      const userUpdatedObj = {
        _id: users._id,
        Limit: users.Limit,
        Plan: users.Plan,
        Status: users.Status,
        companyEmail: users.companyEmail,
        companyEmailPassword: users.companyEmailPassword,
        companyLocation: users.companyLocation,
        companyName: users.companyName,
        userId: users.userId,
        userName: users.userName,
        CreatedInterviews: (users.CreatedInterviews || 0) + 1,
      }

      // Save to database
      const interviewAddApi = await postReq("/interview/CreateInterview", interviewData)
      const userUpdateApi = await putReq("/users/UpdateUser", userUpdatedObj)

      if (interviewAddApi && userUpdateApi) {
        Swal.fire({
          icon: "success",
          title: "Interview Created Successfully",
          text:
            candidateNotifications.length > 0
              ? `Interview created with ${candidateNotifications.length} notification(s) configured.`
              : "Interview created without notifications.",
          toast: true,
          position: "top-end",
          showConfirmButton: false,
          timer: 4000,
          timerProgressBar: true,
        })

        // Clear local storage
        localStorage.removeItem("interviewData")

        setTimeout(() => {
          navigate("/All-Interviews")
        }, 4000)
      } else {
        throw new Error("Failed to save interview to database")
      }
    } catch (error) {
      console.error("Error saving interview:", error)
      Swal.fire({
        icon: "error",
        title: "Save Error",
        text: error.message || "An error occurred while saving the interview. Please try again.",
      })
    } finally {
      setIsUploading(false)
    }
  }

  return (
    <div className="enhanced-interview-creator">
      <div className="flex">
        <Link to="/All-Interviews"></Link>
        {step === 1 && (
          <Step1
            nextStep={moveToStepForward}
            prevStep={moveToStepPrevious}
            candidateThinkingTime={setCandidateThinkingTime}
            candidateMaxAnswerLength={setCandidateMaxAnswerLength}
            brandingColorOrLogo={setBrandingColorOrLogo}
            answerRetakesAllowed={setAnswerRetakesAllowed}
            candidateThinkingTimeValue={candidateThinkingTime}
            candidateMaxAnswerLengthValue={candidateMaxAnswerLength}
            brandingColorOrLogoValue={brandingColorOrLogo}
            answerRetakesAllowedValue={answerRetakesAllowed}
            candidateNotifications={candidateNotifications}
            setCandidateNotifications={setCandidateNotifications}
          />
        )}
        {step === 2 && (
          <Step2
            prevStep={moveToStepPrevious}
            interviewStartTitle={interviewStartTitle}
            setInterviewStartTitle={setInterviewStartTitle}
            interviewStartVideo={interviewStartVideo}
            setInterviewStartVideo={setInterviewStartVideo}
            interviewStartTag={interviewStartTag}
            setInterviewStartTag={setInterviewStartTag}
            questions={questions}
            setQuestions={setQuestions}
            farewell={farewell}
            setFarewell={setFarewell}
            saveInterview={saveInterview}
            isUploading={isUploading}
            candidateThinkingTime={candidateThinkingTime}
            candidateMaxAnswerLength={candidateMaxAnswerLength}
            answerRetakesAllowed={answerRetakesAllowed}
          />
        )}
      </div>
    </div>
  )
}

export default CreateInterview












const InterviewModel = require("../../Model/InterviewSchema/InterviewSchema")

async function CreateInterview(req, res) {
  try {
    const body = req.body

    // üîç Log data in terminal (backend console)
    console.log("Frontend sent body:", body)
    console.log("Candidate Notifications:", body.candidateNotifications)

    // Validate notifications if any are provided
    if (body.candidateNotifications && body.candidateNotifications.length > 0) {
      // Check if all notifications have required fields
      const invalidNotifications = body.candidateNotifications.filter(
        (notification) => !notification.method || !notification.to || !notification.trigger,
      )

      if (invalidNotifications.length > 0) {
        return res.status(400).json({
          Message: "Invalid notification data",
          error: "All notifications must have method, to, and trigger fields",
        })
      }

      // Check maximum limit
      if (body.candidateNotifications.length > 3) {
        return res.status(400).json({
          Message: "Too many notifications",
          error: "Maximum of 3 notifications allowed",
        })
      }
    }

    // Interview create karo
    const createdInterview = await InterviewModel.create(body)

    // Log what was actually saved
    console.log("Saved notifications:", createdInterview.candidateNotifications)

    // Frontend ko response do (yahan dena zaroori hai warna frontend hang ho jayega
    return res.status(201).json({
      Message: "Interview Created Successfully",
      createdInterview,
      notificationCount: createdInterview.candidateNotifications?.length || 0,
    })
  } catch (e) {
    console.error("Error:", e)
    return res.status(500).json({ Message: "Server Problem", error: e.message })
  }
}

async function GetInterviews(req, res) {
  try {
    // Fetch all interviews from the database
    const interviews = await InterviewModel.find()

    // Return the fetched interviews in the response
    return res.status(200).json({
      Message: "All Interviews Fetched Successfully",
      interviews,
    })
  } catch (e) {
    console.error("Error:", e)
    return res.status(500).json({ Message: "Server Problem" })
  }
}

async function GetFilteredInterviews(req, res) {
  try {
    const { interviewIds } = req.body

    // Fetch only those interviews whose _id exists in interviewIds array
    const interviews = await InterviewModel.find({ _id: { $in: interviewIds } })

    res.status(200).json({ Message: "Interviews getted seuccessfully", FilteredInterviews: interviews })
  } catch (error) {
    res.status(500).json({ message: "Error fetching interviews", error })
  }
}

async function FilterInterviewById(req, res) {
  try {
    const { _id } = req.body

    if (!_id) {
      return res.status(400).json({ message: "Interview ID is required" })
    }

    // Fetch the interview by ID
    const interview = await InterviewModel.findById(_id)

    if (!interview) {
      return res.status(404).json({ message: "Interview not found" })
    }

    res.status(200).json({
      message: "Interview retrieved successfully",
      interview,
    })
  } catch (error) {
    res.status(500).json({ message: "Error fetching interview", error: error.message })
  }
}

async function DeleteInterview(req, res) {
  try {
    const { _id } = req.body // Get the ID from the request body

    // Validate ID
    if (!_id) {
      return res.status(400).json({ Message: "Interview ID is required" })
    }

    // Delete the specific interview by ID
    const deletedInterview = await InterviewModel.findByIdAndDelete(_id)

    // Check if the interview was found and deleted
    if (!deletedInterview) {
      return res.status(404).json({ Message: "Interview not found" })
    }

    return res.status(200).json({
      Message: "Interview deleted successfully",
      DeletedInterview: deletedInterview, // Optional: Return the deleted document
    })
  } catch (error) {
    console.error("Error deleting interview:", error)
    return res.status(500).json({ Message: "Server problem", Error: error.message })
  }
}

async function GetInterviewsbyEmail(req, res) {
  try {
    const { email } = req.body // Extract email from request body

    // Validate email
    if (!email) {
      return res.status(400).json({ Message: "Email is required" })
    }

    // Find all interviews matching the email
    const interviews = await InterviewModel.find({ email })

    // Check if any interviews exist
    if (interviews.length === 0) {
      return res.status(404).json({ Message: "No interviews found" })
    }

    return res.status(200).json({
      Message: "Interviews found successfully",
      interviews, // Return all found interviews
    })
  } catch (error) {
    console.error("Error fetching interviews:", error)
    return res.status(500).json({ Message: "Server problem", Error: error.message })
  }
}

const updateInterviewStatus = async (req, res) => {
  try {
    const { _id, Status } = req.body // Get interview ID and new Status from request body

    if (!_id || !Status) {
      return res.status(400).json({ message: "Interview ID and Status are required" })
    }

    const updatedInterview = await InterviewModel.findByIdAndUpdate(
      _id,
      { Status },
      { new: true }, // Returns the updated document
    )

    if (!updatedInterview) {
      return res.status(404).json({ message: "Interview not found" })
    }

    res.status(200).json({
      message: "Interview Status updated successfully",
      updatedInterview,
    })
  } catch (error) {
    console.error("Error updating interview Status:", error)
    res.status(500).json({ message: "Internal server error", error })
  }
}

async function UpdateInterview(req, res) {
  try {
    const { _id, ...updatedData } = req.body // Extract _id and the rest of the updated data
    console.log(_id, "id-updatedData")
    console.log(updatedData, "updatedData")

    // Validate ID and updated data
    if (!_id) {
      return res.status(400).json({ Message: "Interview ID is required" })
    }

    // Validate notifications if being updated
    if (updatedData.candidateNotifications) {
      if (updatedData.candidateNotifications.length > 3) {
        return res.status(400).json({
          Message: "Too many notifications",
          error: "Maximum of 3 notifications allowed",
        })
      }

      const invalidNotifications = updatedData.candidateNotifications.filter(
        (notification) => !notification.method || !notification.to || !notification.trigger,
      )

      if (invalidNotifications.length > 0) {
        return res.status(400).json({
          Message: "Invalid notification data",
          error: "All notifications must have method, to, and trigger fields",
        })
      }
    }

    // Update the interview by ID with the new data
    const updatedInterview = await InterviewModel.findByIdAndUpdate(
      _id,
      updatedData,
      { new: true }, // Returns the updated document
    )

    // Check if the interview was found and updated
    if (!updatedInterview) {
      return res.status(404).json({ Message: "Interview not found" })
    }

    return res.status(200).json({
      Message: "Interview updated successfully",
      UpdatedInterview: updatedInterview, // Return the updated document
      notificationCount: updatedInterview.candidateNotifications?.length || 0,
    })
  } catch (error) {
    console.error("Error updating interview:", error)
    return res.status(500).json({ Message: "Server problem", Error: error.message })
  }
}

// Updated function to handle dynamic notification sending
async function SendCandidateNotification(req, res) {
  try {
    const { interviewId, candidateEmail, candidatePhone } = req.body

    // Validate required fields
    if (!interviewId || !candidateEmail) {
      return res.status(400).json({
        message: "Interview ID and candidate email are required",
      })
    }

    // Fetch interview details
    const interview = await InterviewModel.findById(interviewId)
    if (!interview) {
      return res.status(404).json({ message: "Interview not found" })
    }

    const notifications = interview.candidateNotifications || []

    if (notifications.length === 0) {
      return res.status(400).json({
        message: "No notifications configured for this interview",
      })
    }

    // Process each notification
    const notificationResults = []

    for (const notification of notifications) {
      // Here you would implement the actual email/SMS sending logic
      // For now, we'll just log the notification details
      console.log("Sending notification:", {
        type: notification.to,
        method: notification.method,
        recipient: candidateEmail,
        trigger: notification.trigger,
        interviewTitle: interview.interviewTitle,
      })

      // Simulate notification sending
      const result = {
        id: notification.id,
        type: notification.to,
        method: notification.method,
        recipient: candidateEmail,
        trigger: notification.trigger,
        sent: true,
        timestamp: new Date(),
      }

      notificationResults.push(result)
    }

    return res.status(200).json({
      message: "Notifications sent successfully",
      notificationResults,
      totalSent: notificationResults.length,
    })
  } catch (error) {
    console.error("Error sending notifications:", error)
    return res.status(500).json({
      message: "Server problem",
      error: error.message,
    })
  }
}

// New function to get notification statistics
async function GetNotificationStats(req, res) {
  try {
    const stats = await InterviewModel.aggregate([
      {
        $project: {
          email: 1,
          interviewTitle: 1,
          notificationCount: { $size: { $ifNull: ["$candidateNotifications", []] } },
          notifications: "$candidateNotifications",
        },
      },
      {
        $group: {
          _id: null,
          totalInterviews: { $sum: 1 },
          interviewsWithNotifications: {
            $sum: { $cond: [{ $gt: ["$notificationCount", 0] }, 1, 0] },
          },
          totalNotifications: { $sum: "$notificationCount" },
          avgNotificationsPerInterview: { $avg: "$notificationCount" },
        },
      },
    ])

    return res.status(200).json({
      message: "Notification statistics retrieved successfully",
      stats: stats[0] || {
        totalInterviews: 0,
        interviewsWithNotifications: 0,
        totalNotifications: 0,
        avgNotificationsPerInterview: 0,
      },
    })
  } catch (error) {
    console.error("Error getting notification stats:", error)
    return res.status(500).json({
      message: "Server problem",
      error: error.message,
    })
  }
}

module.exports = {
  CreateInterview,
  GetInterviews,
  DeleteInterview,
  GetFilteredInterviews,
  FilterInterviewById,
  GetInterviewsbyEmail,
  updateInterviewStatus,
  UpdateInterview,
  SendCandidateNotification,
  GetNotificationStats,
}










const express = require("express")
const Router = express.Router()
const InterviewController = require("../../Controller/InterviewControllers/InterviewControler")

Router.post("/CreateInterview", InterviewController.CreateInterview)
Router.get("/GetInterviews", InterviewController.GetInterviews)
Router.post("/DeleteInterview", InterviewController.DeleteInterview)
Router.post("/GetFilteredInterviews", InterviewController.GetFilteredInterviews)
Router.post("/FilterInterviewById", InterviewController.FilterInterviewById)
Router.post("/GetInterviewsbyEmail", InterviewController.GetInterviewsbyEmail)
Router.post("/updateInterviewStatus", InterviewController.updateInterviewStatus)
Router.put("/UpdateInterview/:id", InterviewController.UpdateInterview)
Router.post("/SendCandidateNotification", InterviewController.SendCandidateNotification)
Router.get("/GetNotificationStats", InterviewController.GetNotificationStats)

module.exports = Router
